\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{September 1st, 2015 Pre-Class Questions}
\author{Elliot Cartee}

\begin{document}
\maketitle
\subsection*{Question 1}

Each of the Xeon Phi 5110P boards has a frequency of 1.053 GHz with 60 cores

Source: 
\begin{verbatim}
http://ark.intel.com/products/71992/Intel-Xeon-Phi-Coprocessor-5110P-8GB-1_053-GHz-60-core
\end{verbatim}
	
Each core can compute 16 double precision floating point operations per cycle

Source: 
\begin{verbatim}
https://software.intel.com/en-us/articles/intel-xeon-phi-core-micro-architecture
\end{verbatim}
	
Each of the 8 nodes has a Intel Xeon E5-2620 v3 processor, which has 12 cores at a base frequency of 2.4 GHz

Source: 
\begin{verbatim}
http://ark.intel.com/products/83352/Intel-Xeon-Processor-E5-2620-v3-15M-Cache-2_40-GHz
\end{verbatim}

The above source also says it uses the AVX 2.0 instruction set. According to the source below, this can compute 16 double precision floating point operations per clock.

Source: 
\begin{verbatim} 
http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/
performance-xeon-e5-v3-advanced-vector-extensions-paper.pdf 
\end{verbatim}

(Note that I had to split the URL into two lines because it is too long for the page)



This means that the theoretical peak flop rate from the accelerators is:
$$
\mbox{(\# of cores)*(cycles per second)*(flops per cycle) } 
$$
$$
= (15*60)*(1.053 \mbox{ GHz})*(16) = 15163.2 \mbox{GFlop/sec} = 15.2 \mbox{TFlop/sec}
$$

And the theoretical peak flop rate from the nodes is:
$$
\mbox{(\# of cores)*(cycles per second)*(flops per cycle) } 
$$
$$
= (8*12)*(2.4 \mbox{ GHz})*(16) = 3686.4 \mbox{GFlop/sec} = 3.7 \mbox{TFlop/sec}
$$

Together this comes out to a theoretical peak flop rate of:
$$15.2 \mbox{TFlop/sec} + 3.7 \mbox{TFlop/sec} = 18.9 \mbox{TFlop/sec} $$

\subsection*{Question 2}

My machine is a mid-2012 13-inch Macbook Air. It has a 1.8 GHz Intel Core i5 processor with two cores
Source: 
\begin{verbatim}
http://ark.intel.com/products/64903/Intel-Core-i5-3427U-Processor-3M-Cache-up-to-2_80-GHz
\end{verbatim}

Since this CPU uses the AVX instruction set, it can execute 8 double precision flops per cycle,
So the theoretical peak flop rate is:
$$
\mbox{(\# of cores)*(cycles per second)*(flops per cycle) }
$$
$$
= (2)*(1.8 \mbox{ GHz})*(16) = 57.6 \mbox{GFlop/sec}
$$

\subsection*{Question 3}
Suppose there are $t$ tasks that can be executed in a pipeline with $p$ stages.

Suppose each stage takes time $s$. Then serial execution takes time $t*p*s$, as each stage is executed independently.

Meanwhile, in a pipeline with $p$ stages, each processor would execute the first stage of each task one at a time, so the last processor would begin working at time $(t-1)*s$ and work for a time $p*s$, thus taking a total time of $(p+t-1)*s$. Therefore the ideal speedup is:
$$
\frac{t*p*s}{(t+s-1)*p} = \frac{t*p}{t+p-1}
$$

\subsection*{Question 4}
Given the list of tasks, the minimum serial time would be the sum of the times to compile each component, which is
$$
1 \mbox{ hour } + 0.5 \mbox{ hours } + 0.25 \mbox{ hours } + 0.5 \mbox{ hours} + 0.5 \mbox{ hours } = 2.75 \mbox { hours}
$$

We will now calculate the minimum amount of time given an arbitrary number of processors.

First, we must compile GCC, which will take 1 hour. Then we can simultaneously compile both OpenMPI and OpenBLAS, the latter will take 0.25 hours. Once OpenBLAS is compiled, only then can we compile LAPACK which will take 0.5 hours. OpenMPI will have finished compiling by then. Only once those are all done can the application be compiled which will take 0.5 hours. Therefore the total time in the parallel case is:
$$
1 \mbox{ hour } + 0.25 \mbox{ hours } + 0.5 \mbox{ hours} + 0.5 \mbox{ hours } = 2.25 \mbox { hours}
$$





\end{document}  















